datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

/// A user.
model User {
  // BASIC INFO
  /// The unique identifier of a user.
  id                  Int       @id @default(autoincrement())
  /// The user's email address (must be unique).
  email               String    @unique
  /// The user's hashed password.
  hashedPassword      String
  /// The salt used to hash the user's password.
  salt                String
  /// A reset token for the user's password if generated.
  resetToken          String?
  /// The time at which the reset token expires.
  resetTokenExpiresAt DateTime?

  // RELATIONSHIP INFO
  /// All of the user's games.
  games Game[]
}

/// Possible game types.
enum GameType {
  /// A game where a user is given a word and must select the correct category.
  SORTING
  /// A game where a user must match two words with the same phoneme.
  MATCHING
}

/// A base game. Can be used for any game type.
model Game {
  // BASIC INFO
  /// The unique identifier of a game.
  id        Int      @id @default(autoincrement())
  /// The ID of the user who is playing the game.
  userId    Int
  /// The time at which the game was created.
  createdAt DateTime @default(now())
  /// The time at which the game was last updated.
  updatedAt DateTime @updatedAt
  /// The type of game.
  type      GameType

  // GAMEPLAY INFO
  /// The number of words played per phoneme. The actual number of words played will be this number times the number of phonemes, or less if there are not enough words.
  wordsPerPhoneme Int
  /// The phonemes to test the user on.
  phonemes        Int[]
  /// The current level of the game. Levels are unique to each game type, but all start at 1.
  level           Int     @default(1)
  /// If the game is complete.
  complete        Boolean @default(false)
  /// The current word being played.
  currentWordId   Int?

  // RELATIONSHIP INFO
  /// The user who is playing the game.
  user            User   @relation(fields: [userId], references: [id])
  /// The current word being played. Can be null if the game is complete.
  currentWord     Word?  @relation("currentGames", fields: [currentWordId], references: [id])
  /// All of the words played in the game.
  allWords        Word[] @relation("allGames")
  /// All of the words that have not been played in the game.
  incompleteWords Word[] @relation("incompleteGames")
}

model Word {
  // Basic info
  id              Int      @id @default(autoincrement())
  word            String   @unique
  gradeLevel      Int
  numSyllables    Int
  phonemes        Int[]
  testedPhonemes  Int[]
  graphemes       String[]
  testedGraphemes String[]
  syllables       String[]
  sentences       String[]

  // Relationship info
  currentGames    Game[] @relation("currentGames")
  allGames        Game[] @relation("allGames")
  incompleteGames Game[] @relation("incompleteGames")
}
